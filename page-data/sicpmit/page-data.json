{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/sicpmit","result":{"data":{"post":{"__typename":"MdxPost","slug":"/sicpmit","title":"SICP — (Book + MIT 6.001 + Berkeley CS61A) Notes","date":"07.06.2021","tags":[{"name":"Book notes","slug":"book-notes"}],"description":null,"canonicalUrl":"https://elvischidera.com/sicpmit/","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"SICP — (Book + MIT 6.001 + Berkeley CS61A) Notes\",\n  \"slug\": \"/sicpmit\",\n  \"date\": \"2021-06-07T00:00:00.000Z\",\n  \"canonicalUrl\": \"https://elvischidera.com/sicpmit/\",\n  \"tags\": [\"Book notes\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"MIT 6.001 Structure and Interpretation, 1986\"), mdx(\"h2\", null, \"Lecture 1A: Overview and Introduction to Lisp\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Fixed point of a function.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"We're not only building boxes that input and output numbers. We're building boxes that can compute methods. We can have procedures whose values is another procedure.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Big Topic 1: Black-Box Abstraction\\n\", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Capturing Common Patterns\"), \"\\ni. High-order procedures\\nii. Data as procedures\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Big Topic 2: Conventional Interfaces\\ni. Generic operations\\nii. Large-scale structure and modularity\\niii. Object-orientated programming\\niv. Operation on aggregates\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Big Topic 3: Metalinguistic Abstraction - making new languages\\ni. Interpretation: Apply-Eval\\nii. Example: Logic programming\\niii. Register machine\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Learning a new language, know:\\ni. Primitive elements.\\nii. Means of combination (create bigger things out of primitive elements) and\\niii. Means of abstraction (How to draw black-boxes around the combination -- give a combination a name so it can be used with its details suppressed -- as if they were primitive elements).\")), mdx(\"h2\", null, \"Lecture 1B: Procedures and Processes; Substitution Model\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Substitution model\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"An iteration has all of its state in explicit variables. Recursion has implicit state.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Peano arithmetic recursively and iteratively. Linear iteration takes constant space and linear time. Linear recursion takes both linear time and space.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Recursive definition != Recursive process.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Recursion has work to be done later.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Forward euler method.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"perturbation analysis\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Towers of Hanoi problem\")), mdx(\"h2\", null, \"Lecture 2A: Higher-order Procedures\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"How to think recursively:\\na. Write down the answer to an easy case that is known.\\nb. Reduce the problem to a simpler problem -- make a subproblem of the simpler problem and do something to the result.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scheme\"\n  }), \"; Implementation of SIGMA (i) from INDEX to UPPER_BOUND\\n(DEFINE (SUM_INT index upper_bound)\\n   (IF (> index upper_bound)\\n      0 ; Easy case\\n      (+\\n         index\\n         (SUM_INT (1+ index) upper_bound) ; Reduced simpler problem -- subproblem to solve for\\n      )\\n   )\\n)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scheme\"\n  }), \"; Implementation of SIGMA (i\\xB2) from INDEX to UPPER_BOUND\\n(DEFINE (SUM_SQUARE index upper_bound)\\n   (IF (> index upper_bound)\\n      0\\n      (+\\n         (SQUARE index)\\n         (SUM_SQUARE (1+ index) upper_bound)\\n      )\\n   )\\n)\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Generalizing summation using higher order procedures\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scheme\"\n  }), \"; Recursively\\n(DEFINE (SUMMATION term index index_stepper upper_bound)\\n   (IF (> index upper_bound)\\n      0\\n      (+\\n         (term index) ; term provides term at index\\n         (SUMMATION\\n            term\\n            (index_stepper index)\\n            index_stepper\\n            upper_bound\\n         )\\n      )\\n   )\\n)\\n\\n; Iteratively\\n(DEFINE (SUMMATION term lower_bound index_stepper upper_bound)\\n   (DEFINE (ITER index accumulator)\\n      (IF (> index upper_bound)\\n         accumulator\\n         (ITER\\n            (index_stepper index)\\n            (+\\n               accumulator\\n               (term index)\\n            )\\n         )\\n      )\\n   )\\n\\n   (ITER lower_bound 0)\\n)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scheme\"\n  }), \"(DEFINE (SUM_INT index upper_bound)\\n   (SUMMATION\\n      (LAMBDA (x) x)\\n      index\\n      +1\\n      upper_bound\\n   )\\n)\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Procedures are also data -- they are not special. They can be named.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A procedure for improving a guess of square roots.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scheme\"\n  }), \"(define (sqrt x)\\n   (define tolerance 0.00001)\\n\\n   (define (good-enough? candidate)\\n      (<\\n         (abs (- (* candidate candidate) x))\\n         tolerance\\n      )\\n   )\\n\\n   (define (improve candidate)\\n      (average\\n         (/ x candidate)\\n         candidate\\n      )\\n   )\\n\\n   (define (find-sqrt candidate)\\n      (if (good-enough? candidate)\\n         candidate\\n         (find-sqrt (improve candidate))\\n      )\\n   )\\n\\n   (find-sqrt 1)\\n)\\n\\n(define (average m n)\\n   (/\\n      (+ m n)\\n      2\\n   )\\n)\\n\")), mdx(\"ol\", {\n    \"start\": 5\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A fixed-point is a place which has the property, that the input of the function is its output.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"improve\"), \"(candiate) -> (candidate + (x / candidate)) / 2\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"improve\"), \"(\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"sqrt\"), \"(x)) = \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"sqrt\"), \"(x)\\nExample:\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"improve\"), \"(\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"sqrt\"), \"(9)) = (3 + (9 / 3)) / 2 = (3 + 3) / 2 = 3\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Therefore, the fixed-point of the function \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"improve\"), \"(candidate) is what is desired.\")), mdx(\"ol\", {\n    \"start\": 6\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Some functions have the property that their fixed-point can be found by iterating the function itself -- essentially what is happening in the square-root procedure by Heron's method.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scheme\"\n  }), \"(define (fixed-point function start)\\n   \\n   (define tolerance 0.00001)\\n\\n   ; Checks if two input are close enough as defined by the tolerance\\n   (define (close-enough m n)\\n      (<\\n         (abs (- m n))\\n         tolerance\\n      )\\n   )\\n\\n   ; Repeat until old and new are close enough\\n   (define (iter old new)\\n      (if (close-enough old new)\\n         new\\n         (iter new (function new))\\n      )\\n   )\\n\\n   (iter start (function start))\\n)\\n\\n(define (sqrt x)\\n   (fixed-point\\n      (lambda (b)\\n         (/\\n            (+ b (/ x b))\\n            2\\n         )\\n      )\\n      1\\n   )\\n)\\n\")), mdx(\"ol\", {\n    \"start\": 7\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"There are other functions whose fixed-point is the square root of x, eg:\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"improve(candidate) = (x / candidate)\")), mdx(\"p\", null, \"However the example above oscilates when iterated.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"when x = 2\\nimprove(1) = 2 / 1 = 2\\nimprove(2) = 2 / 2 = 1\\nimprove(1) = 2 / 1 = 2\")), mdx(\"ol\", {\n    \"start\": 8\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The function in (7) can be damped using averaging to find the fixed-point.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scheme\"\n  }), \"(define (sqrt x)\\n   (fixed-point\\n      (average-damp\\n         (lambda (candidate)\\n            (/ x candidate)\\n         )\\n      )\\n      1\\n   )\\n)\\n\\n; Higher-order procedure: Procedure that takes procedure as argument and returns a procedure as value.\\n(define average-damp\\n   (lambda (function)\\n      (lambda (x)\\n         (average (function x) x)\\n      )\\n   )\\n)\\n\")), mdx(\"ol\", {\n    \"start\": 9\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Procedure compute function\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Leibnitz formula for finding pi / 8.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Newton's method\")), mdx(\"h2\", null, \"Lecture 2B: Compound Data\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Recap -- Framework for talking about languages:\\na. Primitives: Things built into the system.\\nb. Means of combination: Where complicated things are built from primitive things.\\nc. Means of abstraction: Where those complicated things can be named and used as simple building blocks.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The task of building things can be divorced from the task of implementing the parts using abstraction boundaries that allows a system to be built in layers. Eg: The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sqrt\"), \" function uses \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"good-enough\"), \" function. The implementation details of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"good-enough\"), \" is irrelevant to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sqrt\"), \" -- it could be using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"abs\"), \" or any other function for its implementation.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  })), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\\"I said that computer science is a lot like magic, and it's sort of good that it's like magic. There's a bad part of computer science that's a lot like religion. And in general, I think people who really believe that you design everything before you implement it basically are people who haven't designed very many things.\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The real power is that you can pretend that you've made the decision and then later on figure out which one is right, which decision you ought to have made. And when you can do that, you have the best of both worlds.\\\" \"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"~Harold Abelson, 1986\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"MIT 6.001 Structure and Interpretation, 1986 Lecture 1A: Overview and Introduction to Lisp Fixed point of a function. We're not only…","timeToRead":2,"banner":null}},"pageContext":{"slug":"/sicpmit","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}